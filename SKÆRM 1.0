float freezing = 15.2;
float hot = 36.0;

#include <stdint.h>
#include <MCUFRIEND_kbv.h>
#include <TouchScreen.h>
///////////////////  Multiplex Control pins
// Mux control pins
int s0 = 28;   // Digital pin1
int s1 = 29;   // Digital pin2
int s2 = 30;   // Digital pin3
int s3 = 31;   // Digital pin4

// Mux in "SIG" pin
int SIG_pin = 15; // A Input pin
////////////// Settings for sk√¶rm
#define LCD_CS A3
#define LCD_CD A2
#define LCD_WR A1
#define LCD_RD A0
#define LCD_RESET A4

MCUFRIEND_kbv tft;
//240 x 320
#define TS_MINX 140
#define TS_MINY 140
#define TS_MAXX 900	
#define TS_MAXY 900

#define YP A2
#define XM A3
#define YM 8
#define XP 9
TouchScreen ts = TouchScreen(XP, YP, XM, YM, 300);
/////////////FARVER
#define BLACK       0x0000
#define BLUE        0x001F
#define RED         0xF800
#define GREEN       0x07E0
#define CYAN        0x07FF
#define MAGENTA     0xF81F
#define YELLOW      0xFFE0
#define WHITE       0xFFFF
#define ORANGE      0xFDA0
#define PINK        0xFC9F
#define PURPLE      0x8010
#define BROWN       0xA145
#define GOLD        0xA508
#define SILVER      0xC618
#define DARKRED     0x8800
#define DARKGREEN   0x0400
#define DARKBLUE    0x0010
#define DARKCYAN    0x0451
#define DARKMAGENTA 0x8811
#define HOTPINK 0xA020F0
#define DARKGRAY 0x8410
#define GRAY 0x808080


// Farve Konstanter
int freeze_color = BLUE;
int hot_color = RED;
int normal_color = GREEN;
int graph_color = CYAN;


void background(){
  tft.fillScreen(BLACK);
  tft.setTextSize(1);
  tft.setCursor(0, 230);
  tft.print("Made by Mattias & Emil");
}
void exit_button() {
  tft.fillRoundRect(260+2, 210+2, 55, 25,5, WHITE);
  tft.fillRoundRect(260, 210, 55, 25,5, RED);
  tft.drawRoundRect(260, 210, 55, 25, 5, WHITE);
  tft.setTextColor(WHITE);
  tft.setTextSize(2);
  tft.setCursor(260+5, 210+5);
  tft.print("Exit");
}
void sensor_boxes(int startX, int startY, int boxWidth, int boxHeight, int gapX, int gapY) {
  for (int row = 0; row < 4; row++) {
      for (int col = 0; col < 4; col++) {
          int x = startX + (col * (boxWidth + gapX));
          int y = startY + (row * (boxHeight + gapY));
          tft.drawRoundRect(x+2, y+2, boxWidth, boxHeight,5, WHITE);
          tft.fillRoundRect(x+2, y+2, boxWidth, boxHeight,5, WHITE);
          tft.fillRoundRect(x, y, boxWidth, boxHeight,5, BLACK);
          tft.drawRoundRect(x, y, boxWidth, boxHeight,5, WHITE);
          tft.setCursor(x+14 , y + boxHeight + 4);
          tft.setTextColor(WHITE);
          tft.setTextSize(1);
          tft.print(String(row * 4 + col + 1)+".");
      }
  }
}
void text(const char* text, int x, int y,int size, int color1, int color2 ) {
  tft.setTextSize(size);
  tft.setTextColor(color1);
  tft.setCursor(x+1, y+1);
  tft.print(text);
  tft.setTextColor(color2);
  tft.setCursor(x, y);
  tft.print(text);
}
void number(float number, int x, int y,int size, int color1, int color2 ) {
  tft.setTextSize(size);
  tft.setTextColor(color1);
  tft.setCursor(x+1, y+1);
  tft.print(number,1);
  tft.setTextColor(color2);
  tft.setCursor(x, y);
  tft.print(number,1);
}
void menu_screen() {
  background();
  ///////////////// ALL SENSORS
  tft.fillRoundRect(45+5, 40+5, 230, 50, 5, WHITE);
  tft.fillRoundRect(45, 40, 230, 50, 5, RED);  // x, y, width, height, color
  tft.drawRoundRect(45, 40, 230, 50, 5, WHITE);  // x, y, width, height, color
  text("All Sensors", 60, 55,3, BLACK, WHITE );
  ///////////////// Noget
  tft.fillRoundRect(45+5, 100+5, 230, 50, 5, WHITE);
  tft.fillRoundRect(45, 100, 230, 50, 5, GRAY);  // x, y, width, height, r,color
  tft.drawRoundRect(45, 100, 230, 50, 5, WHITE);  // x, y, width, height, r,color
  text("Something", 60, 115,3, BLACK, WHITE );
  ///////////////// CONFIG
  tft.fillRoundRect(45+5, 160+5, 230, 50, 5, WHITE);
  tft.fillRoundRect(45, 160, 230, 50, 5, DARKGRAY);  // x, y, width, height, r,color
  tft.drawRoundRect(45, 160, 230, 50, 5, WHITE);  // x, y, width, height, r,color
  text("Config", 110, 175,3, BLACK, WHITE );
  while(1){
    TSPoint p = ts.getPoint();
    pinMode(YP, OUTPUT);     //.kbv these pins are shared with TFT
    pinMode(XM, OUTPUT);     //.kbv these pins are shared with TFT
    if (p.z > ts.pressureThreshhold && p.x > 232 && p.x < 829 && p.y > 620 && p.y < 771) { 
        multiple_temperature_screen();
      }
    if (p.z > ts.pressureThreshhold && p.x > 232 && p.x < 829 && p.y > 206 && p.y < 357) { 
        config();
      }
    // if (p.z > ts.pressureThreshhold) {
    //     Serial.print("X = "); Serial.print(p.x);
    //     Serial.print("\tY = "); Serial.print(p.y);
    //     Serial.print("\tPressure = "); Serial.println(p.z);
    // }
  }
}
void color_window(const char* setting) {
    tft.fillRoundRect(5, 5, 280,230,5, DARKGRAY);  // x, y, width, height, r,color
    tft.drawRoundRect(5, 5, 280, 230,5, WHITE);
    int boxWidth = 40;  
    int boxHeight = 40;
    int gapX = 15;
    int gapY = 15; 
    int startX = 10;    
    int startY = 10;    
    int colorIndex = 0;

    for (int i = 0; i < 20; i++) {
      int posX = startX + (i % 5) * (boxWidth + gapX);  
      int posY = startY + (i / 5) * (boxHeight + gapY);
      switch (colorIndex) {
        case 0:  tft.fillRoundRect(posX+2, posY+2, boxWidth, boxHeight,5, WHITE );tft.fillRoundRect(posX, posY, boxWidth, boxHeight,5, BLACK );tft.drawRoundRect(posX, posY, boxWidth, boxHeight,5, BLACK); break;
        case 1:  tft.fillRoundRect(posX+2, posY+2, boxWidth, boxHeight,5, WHITE );tft.fillRoundRect(posX, posY, boxWidth, boxHeight, 5,BLUE  );tft.drawRoundRect(posX, posY, boxWidth, boxHeight,5, BLACK); break;
        case 2:  tft.fillRoundRect(posX+2, posY+2, boxWidth, boxHeight,5, WHITE );tft.fillRoundRect(posX, posY, boxWidth, boxHeight, 5,RED   );tft.drawRoundRect(posX, posY, boxWidth, boxHeight,5, BLACK); break;
        case 3:  tft.fillRoundRect(posX+2, posY+2, boxWidth, boxHeight,5, WHITE );tft.fillRoundRect(posX, posY, boxWidth, boxHeight, 5,GREEN );tft.drawRoundRect(posX, posY, boxWidth, boxHeight,5, BLACK); break;
        case 4:  tft.fillRoundRect(posX+2, posY+2, boxWidth, boxHeight,5, WHITE );tft.fillRoundRect(posX, posY, boxWidth, boxHeight, 5,CYAN  );tft.drawRoundRect(posX, posY, boxWidth, boxHeight,5, BLACK); break;
        case 5:  tft.fillRoundRect(posX+2, posY+2, boxWidth, boxHeight,5, WHITE );tft.fillRoundRect(posX, posY, boxWidth, boxHeight,5,MAGENTA);tft.drawRoundRect(posX, posY, boxWidth, boxHeight,5, BLACK); break;
        case 6:  tft.fillRoundRect(posX+2, posY+2, boxWidth, boxHeight,5, WHITE );tft.fillRoundRect(posX, posY, boxWidth, boxHeight, 5,YELLOW);tft.drawRoundRect(posX, posY, boxWidth, boxHeight,5, BLACK); break;
        case 7:  tft.fillRoundRect(posX+2, posY+2, boxWidth, boxHeight,5, WHITE );tft.fillRoundRect(posX, posY, boxWidth, boxHeight, 5,WHITE );tft.drawRoundRect(posX, posY, boxWidth, boxHeight,5, BLACK); break;
        case 8:  tft.fillRoundRect(posX+2, posY+2, boxWidth, boxHeight,5, WHITE );tft.fillRoundRect(posX, posY, boxWidth, boxHeight, 5,ORANGE);tft.drawRoundRect(posX, posY, boxWidth, boxHeight,5, BLACK); break;
        case 9:  tft.fillRoundRect(posX+2, posY+2, boxWidth, boxHeight,5, WHITE );tft.fillRoundRect(posX, posY, boxWidth, boxHeight, 5,PINK  );tft.drawRoundRect(posX, posY, boxWidth, boxHeight,5, BLACK); break;
        case 10: tft.fillRoundRect(posX+2, posY+2, boxWidth, boxHeight,5, WHITE );tft.fillRoundRect(posX, posY, boxWidth, boxHeight,5, PURPLE);tft.drawRoundRect(posX, posY, boxWidth, boxHeight,5, BLACK); break;
        case 11: tft.fillRoundRect(posX+2, posY+2, boxWidth, boxHeight,5, WHITE );tft.fillRoundRect(posX, posY, boxWidth, boxHeight,5, BROWN);tft.drawRoundRect(posX, posY, boxWidth, boxHeight,5, BLACK); break;
        case 12: tft.fillRoundRect(posX+2, posY+2, boxWidth, boxHeight,5, WHITE );tft.fillRoundRect(posX, posY, boxWidth, boxHeight,5, GOLD);tft.drawRoundRect(posX, posY, boxWidth, boxHeight,5, BLACK); break;
        case 13: tft.fillRoundRect(posX+2, posY+2, boxWidth, boxHeight,5, WHITE );tft.fillRoundRect(posX, posY, boxWidth, boxHeight,5, SILVER);tft.drawRoundRect(posX, posY, boxWidth, boxHeight,5, BLACK); break;
        case 14: tft.fillRoundRect(posX+2, posY+2, boxWidth, boxHeight,5, WHITE );tft.fillRoundRect(posX, posY, boxWidth, boxHeight,5, DARKRED);tft.drawRoundRect(posX, posY, boxWidth, boxHeight,5, BLACK); break;
        case 15: tft.fillRoundRect(posX+2, posY+2, boxWidth, boxHeight,5, WHITE );tft.fillRoundRect(posX, posY, boxWidth, boxHeight,5, DARKGREEN);tft.drawRoundRect(posX, posY, boxWidth, boxHeight,5, BLACK); break;
        case 16: tft.fillRoundRect(posX+2, posY+2, boxWidth, boxHeight,5, WHITE );tft.fillRoundRect(posX, posY, boxWidth, boxHeight,5, DARKBLUE);tft.drawRoundRect(posX, posY, boxWidth, boxHeight,5, BLACK); break;
        case 17: tft.fillRoundRect(posX+2, posY+2, boxWidth, boxHeight,5, WHITE );tft.fillRoundRect(posX, posY, boxWidth, boxHeight,5, DARKCYAN);tft.drawRoundRect(posX, posY, boxWidth, boxHeight,5, BLACK); break;
        case 18: tft.fillRoundRect(posX+2, posY+2, boxWidth, boxHeight,5, WHITE );tft.fillRoundRect(posX, posY, boxWidth, boxHeight,5, DARKMAGENTA);tft.drawRoundRect(posX, posY, boxWidth, boxHeight,5, BLACK); break;
        case 19: tft.fillRoundRect(posX+2, posY+2, boxWidth, boxHeight,5, WHITE );tft.fillRoundRect(posX, posY, boxWidth, boxHeight,5, DARKGRAY);tft.drawRoundRect(posX, posY, boxWidth, boxHeight,5, BLACK); break;
        case 20: tft.fillRoundRect(posX+2, posY+2, boxWidth, boxHeight,5, WHITE );tft.fillRoundRect(posX, posY, boxWidth, boxHeight,5, GRAY);tft.drawRoundRect(posX, posY, boxWidth, boxHeight,5, BLACK); break;
        // Add more colors as needed
        default: tft.fillRoundRect(posX, posY, boxWidth, boxHeight,5, WHITE);tft.drawRoundRect(posX, posY, boxWidth, boxHeight,5, WHITE); break;          
      }
      colorIndex = (colorIndex + 1);
    }
    exit_button();
    while(1) {
      TSPoint p = ts.getPoint();
      pinMode(YP, OUTPUT);     //.kbv these pins are shared with TFT
      pinMode(XM, OUTPUT);     //.kbv these pins are shared with TFT
      if (p.z > ts.pressureThreshhold && p.x > 145 && p.x < 264 && p.y > 143 && p.y < 230) {
        config();
      }
      ////////////////R√ÜKKE 1
      else if (p.z > ts.pressureThreshhold && p.x > 835	 && p.x < 914	) { //R√¶kke 1
        if (p.y > 748	 && p.y < 860	) { //COLUMN 1
          if (setting == "MAX") {
            hot_color =BLACK ;
            config();
          }
          else if (setting == "MIN") {
            freeze_color =BLACK ;
            config();
          }
          else if (setting == "GRAPH") {
            graph_color =BLACK ;
            config();
          }
          else if (setting == "NOM") {
            normal_color = BLACK ;
            config();
          }
        }
        else if (p.y > 569	 && p.y < 680	) { //COLUMN 2
          if (setting == "MAX") {
            hot_color =MAGENTA ;
            config();
          }
          else if (setting == "MIN") {
            freeze_color =MAGENTA ;
            config();
          }
          else if (setting == "GRAPH") {
            graph_color =MAGENTA ;
            config();
          }
          else if (setting == "NOM") {
            normal_color =MAGENTA ;
            config();
          }
        }
        else if (p.y > 384 && p.y < 487	) { //COLUMN 3
          if (setting == "MAX") {
            hot_color =PURPLE ;
            config();
          }
          else if (setting == "MIN") {
            freeze_color =PURPLE ;
            config();
          }
          else if (setting == "GRAPH") {
            graph_color =PURPLE ;
            config();
          }
          else if (setting == "NOM") {
            normal_color =PURPLE ;
            config();
          }
        }
      
        else if (p.y > 205	 && p.y < 306) { //COLUMN 4
          if (setting == "MAX") {
            hot_color =DARKGREEN ;
            config();
          }
          else if (setting == "MIN") {
            freeze_color =DARKGREEN ;
            config();
          }
          else if (setting == "GRAPH") {
            graph_color = DARKGREEN;
            config();
          }
          else if (setting == "NOM") {
            normal_color = DARKGREEN;
            config();
          }
        }
      }
      ////////////////R√ÜKKE 2
      else if (p.z > ts.pressureThreshhold && p.x > 680	 && p.x < 772	) { //R√¶kke 1
        if (p.y > 748	 && p.y < 860	) { //COLUMN 1
          if (setting == "MAX") {
            hot_color =BLUE ;
            config();
          }
          else if (setting == "MIN") {
            freeze_color =BLUE ;
            config();
          }
          else if (setting == "GRAPH") {
            graph_color =BLUE ;
            config();
          }
          else if (setting == "NOM") {
            normal_color =BLUE ;
            config();
          }
        }
        else if (p.y > 569	 && p.y < 680	) { //COLUMN 2
          if (setting == "MAX") {
            hot_color = YELLOW;
            config();
          }
          else if (setting == "MIN") {
            freeze_color =YELLOW ;
            config();
          }
          else if (setting == "GRAPH") {
            graph_color =YELLOW ;
            config();
          }
          else if (setting == "NOM") {
            normal_color = YELLOW;
            config();
          }
        }
        else if (p.y > 384 && p.y < 487	) { //COLUMN 3
          if (setting == "MAX") {
            hot_color = BROWN ;
            config();
          }
          else if (setting == "MIN") {
            freeze_color =BROWN ;
            config();
          }
          else if (setting == "GRAPH") {
            graph_color =BROWN ;
            config();
          }
          else if (setting == "NOM") {
            normal_color =BROWN ;
            config();
          }
        }
        else if (p.y > 205	 && p.y < 306) { //COLUMN 4
          if (setting == "MAX") {
            hot_color =DARKBLUE ;
            config();
          }
          else if (setting == "MIN") {
            freeze_color =DARKBLUE ;
            config();
          }
          else if (setting == "GRAPH") {
            graph_color =DARKBLUE ;
            config();
          }
          else if (setting == "NOM") {
            normal_color = DARKBLUE;
            config();
          }
        }
      }
      ////////////////R√ÜKKE 3
      else if (p.z > ts.pressureThreshhold && p.x > 552	 && p.x < 634	) { //R√¶kke 1
        if (p.y > 748	 && p.y < 860	) { //COLUMN 1
          if (setting == "MAX") {
            hot_color =RED ;
            config();
          }
          else if (setting == "MIN") {
            freeze_color =RED ;
            config();
          }
          else if (setting == "GRAPH") {
            graph_color =RED ;
            config();
          }
          else if (setting == "NOM") {
            normal_color =RED ;
            config();
          }
        }
        else if (p.y > 569	 && p.y < 680	) { //COLUMN 2
          if (setting == "MAX") {
            hot_color = WHITE ;
            config();
          }
          else if (setting == "MIN") {
            freeze_color =WHITE ;
            config();
          }
          else if (setting == "GRAPH") {
            graph_color = WHITE;
            config();
          }
          else if (setting == "NOM") {
            normal_color =WHITE ;
            config();
          }
        }
        else if (p.y > 384 && p.y < 487	) { //COLUMN 3
          if (setting == "MAX") {
            hot_color = GOLD;
            config();
          }
          else if (setting == "MIN") {
            freeze_color =GOLD ;
            config();
          }
          else if (setting == "GRAPH") {
            graph_color = GOLD;
            config();
          }
          else if (setting == "NOM") {
            normal_color = GOLD;
            config();
          }
        }
        else if (p.y > 205	 && p.y < 306) { //COLUMN 4
          if (setting == "MAX") {
            hot_color =DARKCYAN ;
            config();
          }
          else if (setting == "MIN") {
            freeze_color = DARKCYAN;
            config();
          }
          else if (setting == "GRAPH") {
            graph_color =DARKCYAN ;
            config();
          }
          else if (setting == "NOM") {
            normal_color = DARKCYAN;
            config();
          }
        }
      }
      ////////////////R√ÜKKE 4
      else if (p.z > ts.pressureThreshhold && p.x > 400	 && p.x < 490	) { //R√¶kke 1
        if (p.y > 748	 && p.y < 860	) { //COLUMN 1
          if (setting == "MAX") {
            hot_color =GREEN ;
            config();
          }
          else if (setting == "MIN") {
            freeze_color =GREEN ;
            config();
          }
          else if (setting == "GRAPH") {
            graph_color = GREEN;
            config();
          }
          else if (setting == "NOM") {
            normal_color = GREEN;
            config();
          }
        }
        else if (p.y > 569	 && p.y < 680	) { //COLUMN 2
          if (setting == "MAX") {
            hot_color = ORANGE;
            config();
          }
          else if (setting == "MIN") {
            freeze_color = ORANGE;
            config();
          }
          else if (setting == "GRAPH") {
            graph_color =ORANGE ;
            config();
          }
          else if (setting == "NOM") {
            normal_color = ORANGE;
            config();
          }
        }
        else if (p.y > 384 && p.y < 487	) { //COLUMN 3
          if (setting == "MAX") {
            hot_color = SILVER;
            config();
          }
          else if (setting == "MIN") {
            freeze_color =SILVER ;
            config();
          }
          else if (setting == "GRAPH") {
            graph_color = SILVER;
            config();
          }
          else if (setting == "NOM") {
            normal_color = SILVER;
            config();
          }
        }
        else if (p.y > 205	 && p.y < 306) { //COLUMN 4
          if (setting == "MAX") {
            hot_color =DARKMAGENTA ;
            config();
          }
          else if (setting == "MIN") {
            freeze_color =DARKMAGENTA ;
            config();
          }
          else if (setting == "GRAPH") {
            graph_color = DARKMAGENTA;
            config();
          }
          else if (setting == "NOM") {
            normal_color =DARKMAGENTA ;
            config();
          }
        }
      }
      ////////////////R√ÜKKE 5
      else if (p.z > ts.pressureThreshhold && p.x > 256	&& p.x < 347	) { //R√¶kke 1
        if (p.y > 748	 && p.y < 860	) { //COLUMN 1
          if (setting == "MAX") {
            hot_color =CYAN ;
            config();
          }
          else if (setting == "MIN") {
            freeze_color = CYAN;
            config();
          }
          else if (setting == "GRAPH") {
            graph_color = CYAN;
            config();
          }
          else if (setting == "NOM") {
            normal_color = CYAN;
            config();
          }
        }
        else if (p.y > 569	 && p.y < 680	) { //COLUMN 2
          if (setting == "MAX") {
            hot_color = PINK;
            config();
          }
          else if (setting == "MIN") {
            freeze_color = PINK;
            config();
          }
          else if (setting == "GRAPH") {
            graph_color = PINK;
            config();
          }
          else if (setting == "NOM") {
            normal_color = PINK;
            config();
          }
        }
        else if (p.y > 384 && p.y < 487	) { //COLUMN 3
          if (setting == "MAX") {
            hot_color = DARKRED;
            config();
          }
          else if (setting == "MIN") {
            freeze_color =DARKRED ;
            config();
          }
          else if (setting == "GRAPH") {
            graph_color =DARKRED ;
            config();
          }
          else if (setting == "NOM") {
            normal_color =DARKRED ;
            config();
          }
        }
        else if (p.y > 205	 && p.y < 306) { //COLUMN 4
          if (setting == "MAX") {
            hot_color = DARKGRAY;
            config();
          }
          else if (setting == "MIN") {
            freeze_color =DARKGRAY ;
            config();
          }
          else if (setting == "GRAPH") {
            graph_color = DARKGRAY;
            config();
          }
          else if (setting == "NOM") {
            normal_color = DARKGRAY;
            config();
          }
        }
      }

      if (p.z > ts.pressureThreshhold) {
        Serial.print("X = "); Serial.print(p.x);
        Serial.print("\tY = "); Serial.print(p.y);
        Serial.print("\tPressure = "); Serial.println(p.z);
    }
    }
}
void config() {
  background();
  ///// √òverste temperatur config 
  tft.fillRoundRect(1, 1, 319, 75,5, DARKGRAY);  // x, y, width, height, r,color
  tft.drawRoundRect(1, 1, 319, 75,5, WHITE);  // x, y, width, height, r,color
  text("MAX", 10, 10,3,WHITE,hot_color );
  text("MIN", 255, 10,3,WHITE,freeze_color);
  number(hot, 8, 40,3,hot_color,WHITE);
  tft.fillTriangle(80,30,95,5,110,30,WHITE);
  tft.fillTriangle(80,40,95,65,110,40,WHITE);
  number(freezing, 245, 40,3,freeze_color,WHITE);
  tft.fillTriangle(205,30,220,5,235,30,WHITE);
  tft.fillTriangle(205,40,220,65,235,40,WHITE);

  /// Midterste ting:
  tft.fillRoundRect(1, 76, 319, 75,5, DARKGRAY);  // x, y, width, height, r,color
  tft.drawRoundRect(1, 76, 319, 75,5, WHITE);  // x, y, width, height, r,color
  /// Nederste ting:
  tft.fillRoundRect(1, 151, 319, 80,5, DARKGRAY);  // x, y, width, height, r,color
  tft.drawRoundRect(1, 151, 319, 80,5, WHITE);  // x, y, width, height, r,color
  text("Define Colors", 50, 155,3,BLACK,WHITE );
  // HOT COLOR
  text("MAX",68,180,2,BLACK,hot_color);
  tft.fillRoundRect(70+2, 195+2, 30, 30,5, WHITE);
  tft.fillRoundRect(70, 195, 30, 30,5, hot_color);
  tft.drawRoundRect(70, 195, 30, 30,5, WHITE);

  // COLD COLOR
  text("MIN",118,180,2,BLACK,freeze_color);
  tft.fillRoundRect(120+2, 195+2, 30, 30,5, WHITE);
  tft.fillRoundRect(120, 195, 30, 30,5, freeze_color);
  tft.drawRoundRect(120, 195, 30, 30,5, WHITE);
  // NORMAL COLOR
  text("NOM",168,180,2,BLACK,normal_color);
  tft.fillRoundRect(170+2, 195+2, 30, 30,5, WHITE);
  tft.fillRoundRect(170, 195, 30, 30,5, normal_color);
  tft.drawRoundRect(170, 195, 30, 30,5, WHITE);
  //GRAPH COlor
  text("GRAPH",210,180,2,BLACK,graph_color);
  tft.fillRoundRect(220+2, 195+2, 30, 30,5, WHITE);
  tft.fillRoundRect(220, 195, 30, 30,5, graph_color);
  tft.drawRoundRect(220, 195, 30, 30,5, WHITE);


  exit_button();
  while(1) {
    TSPoint p = ts.getPoint();
    pinMode(YP, OUTPUT);     //.kbv these pins are shared with TFT
    pinMode(XM, OUTPUT);     //.kbv these pins are shared with TFT
    if (p.z > ts.pressureThreshhold) {
        Serial.print("X = "); Serial.print(p.x);
        Serial.print("\tY = "); Serial.print(p.y);
        Serial.print("\tPressure = "); Serial.println(p.z);
    }
    if (p.z > ts.pressureThreshhold && p.x > 657 && p.x < 746) { 
      if (p.y > 820 && p.y < 895) {
        hot = hot +0.1;
        tft.fillRoundRect(8, 35, 70, 35,1, DARKGRAY);
        number(hot, 8, 40,3,hot_color,WHITE);
        delay(300);
        }
      else if (p.y > 696 && p.y < 775) {
        hot = hot - 0.1;
        tft.fillRoundRect(8, 35, 70, 35,1, DARKGRAY);
        number(hot, 8, 40,3,hot_color,WHITE);
        delay(300);
        }  
      }
    else if (p.z > ts.pressureThreshhold && p.x > 328 && p.x < 420) { 
      if (p.y > 818 && p.y < 887) {
        freezing = freezing +0.1;
        tft.fillRoundRect(245, 35, 70, 35,1, DARKGRAY);
        number(freezing, 245, 40,3,freeze_color,WHITE);
        delay(300);
      }
      else if (p.y > 689 && p.y < 770) {
        freezing = freezing - 0.1;
        tft.fillRoundRect(245, 35, 70, 35,1, DARKGRAY);
        number(freezing, 245, 40,3,freeze_color,WHITE);
        delay(300);
      }
    }
    else if (p.z > ts.pressureThreshhold && p.x > 145 && p.x < 264 && p.y > 143 && p.y < 230) {
        menu_screen();
      }
    else if (p.z > ts.pressureThreshhold && p.y > 166 && p.y < 243) {
      if (p.x > 692 && p.x < 774) { //MAX
        color_window("MAX");
      }
      else if (p.x > 569 && p.x < 625) { //MIN
        color_window("MIN");
      }
      else if (p.x > 433 && p.x < 500	) { //NOM
        color_window("NOM");
      }
      else if (p.x > 306 && p.x < 366		) { //GRAPH
        color_window("GRAPH");
      }
    }

  }
}
void readTemperature(float &temperature, int &boxIndex) {
  boxIndex = random(0, 16); 
  temperature = random(150, 360) / 10.0; 
}
void temperature_graph(int sensor_ID) { /// SE https://www.hackster.io/andreiflorian/tft-graphing-live-history-graphs-744f3b
  background();
  exit_button();

  //DETTE ER EN TESTER
  int startX = 10;
  int endX = 310;
  int startY = 10;
  int endY = 200;
  tft.setCursor(startX+108, endY+12);
  tft.setTextColor(WHITE);
  tft.print("Sensor " + String(sensor_ID) );


  // TEGB AKSERNE
  tft.drawLine(startX, startY, startX, endY, WHITE); // Y-axis // x1, y1, x2, y2, color
  tft.drawLine(startX, endY, endX, endY, WHITE); // X-axis // x1, y1, x2, y2, color
  

  //Tegn labels:
  tft.setRotation(0);
  tft.setTextSize(1);
  tft.setCursor(startX+100, startY-10);
  tft.setTextColor(WHITE);
  tft.print("Temp (C)");
  tft.setRotation(1);
  tft.setTextSize(1);
  tft.setCursor(startX+125, endY+4);
  tft.print("Time");

  //Tids interval 
  int interval = 100; 
  int graphX = startX+20;
  float graphY;

  while (1) {
    float temp;
    int boxIndex;
    readTemperature(temp, boxIndex);
    boxIndex = boxIndex+1;
    TSPoint p = ts.getPoint();
    pinMode(YP, OUTPUT);     //.kbv these pins are shared with TFT
    pinMode(XM, OUTPUT);     //.kbv these pins are shared with TFT

    if (p.z > ts.pressureThreshhold) {
        Serial.print("X = "); Serial.print(p.x);
        Serial.print("\tY = "); Serial.print(p.y);
        Serial.print("\tPressure = "); Serial.println(p.z);
    }
    if (p.z > ts.pressureThreshhold && p.x > 145 && p.x < 264 && p.y > 143 && p.y < 230) {
        multiple_temperature_screen();
      }

    if (boxIndex != sensor_ID) {
      continue;
    }
    delay(interval);
  }
}
void multiple_temperature_screen(){
  background();
  int startX = 10;
  int startY = 10;
  int boxWidth = 40;
  int boxHeight = 40;
  int gapX = 22;
  int gapY = 14; 
  exit_button();
  sensor_boxes(startX,startY,boxWidth,boxHeight,gapX,gapY);
  text("MAX",250,20,3, WHITE, hot_color );
  number(hot,245,50,3, hot_color, WHITE );
  text("MIN",250,100,3, WHITE, freeze_color );
  number(freezing,245,130,3, freeze_color, WHITE );
  while(1){
    float temp;
    int boxIndex;
    readTemperature(temp, boxIndex);
    int x = startX + ((boxIndex % 4) * (boxWidth + gapX));
    int y = startY + ((boxIndex / 4) * (boxHeight + gapY));
    if (temp > hot) {
      tft.fillRoundRect(x, y, boxWidth, boxHeight,5, hot_color);
      tft.drawRoundRect(x, y, boxWidth, boxHeight,5, WHITE);
      tft.setCursor(x + 5, y + boxHeight / 2);
      tft.setTextColor(WHITE);
      tft.setTextSize(1);
      tft.print(String(round(temp * 10) / 10.0,1) + "C");
    } else if (temp < freezing) {
      tft.fillRoundRect(x, y, boxWidth, boxHeight,5, freeze_color);
      tft.drawRoundRect(x, y, boxWidth, boxHeight,5, WHITE);
      tft.setCursor(x + 5, y + boxHeight / 2);
      tft.setTextColor(WHITE);
      tft.setTextSize(1);
      tft.print(String(round(temp * 10) / 10.0,1) + "C");
    } else {
      tft.fillRoundRect(x, y, boxWidth, boxHeight,5, normal_color); 
      tft.drawRoundRect(x, y, boxWidth, boxHeight,5, WHITE);
      tft.setCursor(x + 5, y + boxHeight / 2);
      tft.setTextColor(BLACK);
      tft.setTextSize(1);
      tft.print(String(round(temp * 10) / 10.0,1) + "C");
    }
    TSPoint p = ts.getPoint();
    pinMode(YP, OUTPUT);     //.kbv these pins are shared with TFT
    pinMode(XM, OUTPUT);     //.kbv these pins are shared with TFT

    if (p.z > ts.pressureThreshhold) {
        Serial.print("X = "); Serial.print(p.x);
        Serial.print("\tY = "); Serial.print(p.y);
        Serial.print("\tPressure = "); Serial.println(p.z);
    }
    if (p.z > ts.pressureThreshhold && p.x > 145 && p.x < 264 && p.y > 143 && p.y < 230) {
        menu_screen();
      }
    else if (p.z > ts.pressureThreshhold && p.x > 826 && p.x < 920) { //F√òRSTE R√ÜKKE
      if (p.y > 752 && p.y < 874) {
        temperature_graph(1);
      }
      if (p.y > 553 && p.y < 689) {
        temperature_graph(5);
      }
      if (p.y > 401 && p.y < 514) {
        temperature_graph(9);
      }
      if (p.y > 208 && p.y < 331) {
        temperature_graph(13);
      }
    }
    else if (p.z > ts.pressureThreshhold && p.x > 675 && p.x < 766) {  /// ANDEN R√ÜKKE
      if (p.y > 752 && p.y < 874) {
        temperature_graph(2);
      }
      if (p.y > 553 && p.y < 689) {
        temperature_graph(6);
      }
      if (p.y > 401 && p.y < 514) {
        temperature_graph(10);
      }
      if (p.y > 208 && p.y < 331) {
        temperature_graph(14);
      }
    }
    else if (p.z > ts.pressureThreshhold && p.x > 512 && p.x < 607) { //TREDJE R√ÜKKE
      if (p.y > 752 && p.y < 874) {
        temperature_graph(3);
      }
      if (p.y > 553 && p.y < 689) {
        temperature_graph(7);
      }
      if (p.y > 401 && p.y < 514) {
        temperature_graph(11);
      }
      if (p.y > 208 && p.y < 331) {
        temperature_graph(15);
      }
    }
    else if (p.z > ts.pressureThreshhold && p.x > 353 && p.x < 454) { //FJERDE R√ÜKKE
      if (p.y > 752 && p.y < 874) {
        temperature_graph(4);
      }
      if (p.y > 553 && p.y < 689) {
        temperature_graph(8);
      }
      if (p.y > 401 && p.y < 514) {
        temperature_graph(12);
      }
      if (p.y > 208 && p.y < 331) {
        temperature_graph(16);
      }
    }
      if (p.z > ts.pressureThreshhold) {
        Serial.print("X = "); Serial.print(p.x);
        Serial.print("\tY = "); Serial.print(p.y);
        Serial.print("\tPressure = "); Serial.println(p.z);
    }
    delay(100);
  }
}
int readMux(float &temperature,int & channel) {
  int controlPin[] = {s0, s1, s2, s3};

  int muxChannel[16][4]={
    {0,0,0,0}, //channel 0
    {1,0,0,0}, //channel 1
    {0,1,0,0}, //channel 2
    {1,1,0,0}, //channel 3
    {0,0,1,0}, //channel 4
    {1,0,1,0}, //channel 5
    {0,1,1,0}, //channel 6
    {1,1,1,0}, //channel 7
    {0,0,0,1}, //channel 8
    {1,0,0,1}, //channel 9
    {0,1,0,1}, //channel 10
    {1,1,0,1}, //channel 11
    {0,0,1,1}, //channel 12
    {1,0,1,1}, //channel 13
    {0,1,1,1}, //channel 14
    {1,1,1,1}  //channel 15
  };

  // Loop through the 4 sig
  for(int i = 0; i < 4; i ++) {
    digitalWrite(controlPin[i], muxChannel[channel][i]);
  }

  // Read the value at the SIG pin
  int val = analogRead(SIG_pin);
  float temp = val * 0.09746588694; // Conv. Const.

  // Return the value
  Serial.print(temp);
  temperature = temp;
}
/*
  for(int i = 0; i < 16; i ++){
    Serial.print("Temperature at channel: ");
    Serial.print(i);
    Serial.print(" is : ");
    Serial.print(readMux(i));
    Serial.println(" degrees celcius");
    delay(1000);
  }
*/

void setup() {
  // Setup Output pins
  pinMode(s0, OUTPUT); 
  pinMode(s1, OUTPUT); 
  pinMode(s2, OUTPUT); 
  pinMode(s3, OUTPUT); 
  // Set all digital pins to low state
  digitalWrite(s0, LOW);
  digitalWrite(s1, LOW);
  digitalWrite(s2, LOW);
  digitalWrite(s3, LOW);
  Serial.begin(9600);

  uint16_t ID = tft.readID();
  tft.begin(ID);

  tft.setRotation(1);  // Landscape orientation
  
  // tft.fillScreen(BLUE);  // Fill screen with blue color
  // tft.setTextColor(WHITE);  // Set text color to white
  // tft.setTextSize(2);  // Set text size to 2
  // Draw a rectangle
  // tft.drawRoundRect(50, 50, 100, 60,5, WHITE);  // x, y, width, height, color

  // // Draw a filled rectangle
  // tft.fillRect(200, 50, 80, 80, RED);  // x, y, width, height, color

  // // Draw a circle
  // tft.drawCircle(0, 0, 30, BLACK);  // x, y, radius, color

  // // Draw a filled circle
  // tft.fillCircle(0, 0, 25, YELLOW);  // x, y, radius, color

  //   // Draw a circle
  // tft.drawCircle(320, 240, 30, BLACK);  // x, y, radius, color

  // // Draw a filled circle
  // tft.fillCircle(320, 240, 25, YELLOW);  // x, y, radius, color

  // // Draw a triangle
  // tft.drawTriangle(50, 250, 100, 300, 0, 300, MAGENTA);  // x1, y1, x2, y2, x3, y3, color

  // // Draw a filled triangle
  // tft.fillTriangle(200, 250, 250, 300, 150, 300, CYAN);  // x1, y1, x2, y2, x3, y3, color
}
void loop() {
  //multiple_temperature_screen();
  menu_screen();
  //temperature_graph(1);
  //config();
}
